# Launching a Matlab script from a Jupyter notebook

**Pedro Arduino - University of Washington**

This document presents a Jupyter Notebook published in DesignSafe that navigate the process of launching a matlab script from jupyter using a DesignSafe matlab Tapis app. It also exemplifies how to combine matlab and python events in a single notebook. The example makes use of the following DesignSafe resources:

[Jupyter notebooks on DS Juypterhub](https://www.designsafe-ci.org/rw/workspace/#!/Jupyter::Analysis){target=_blank}<br/>

<!--
The accompanying jupyter notebook for this use case can be found in the Community Data folder in [matlabBatch-VM.ipynb](https://jupyter.designsafe-ci.org/user/name/lab/workspaces/auto-J/tree/CommunityData/Jupyter%20Notebooks%20for%20Civil%20Engineering%20Courses/University_of_Washington/MatlabBatch/matlabBatch-VM.ipynb)
-->

## Background 
### Citation and Licensing

* Please cite [Rathje et al. (2017)](https://doi.org/10.1061/(ASCE)NH.1527-6996.0000246){target=_blank} to acknowledge the use of DesignSafe resources.  

* This software is distributed under the [GNU General Public License](https://www.gnu.org/licenses/gpl-3.0.html){target=_blank}.  


## Description

The notebook utilizes a MATLAB Tapis app (*MATLAB-2022a-VM-1.0.0*) to launch any MATLAB script. For this instance, a simple MATLAB script serves as a example to showcase how to effectively use the app. The matlab script begins by reading acceleration time histories and performing two integrations to produce velocity and displacement time histories. The script then calculates the response spectra for each motion and generates a sequence of plots, while also saving numerical data in ASCII files.

In a second step, the output files generated by the MATLAB are utilized by Python to generate simple plots. These plots provide an easy-to-understand visualization of the data and enable users to quickly comprehend the results. By combining the capabilities of MATLAB and Python in a single Jupyter notebook, users can develop powerful analysis workflows that can handle complex data sets and generate insightful visualizations.

FInally a simple report is generated using rst2pdf.

A schematic workflow for this example is presented in Fig. 1

<p align="center">
<img src="../img/UC3-Arduino-0.png" alt="Schematic of Matlab workflow" width="500"/>
</p>
<p align="center"> <b>Fig.1 - Schematic of Matlab workflow</b> </p>
    

The notebook, and required scripts, are available in the Community Data folder and can be executed without any modification.
Users are invited to try this notebook and use any parts of it.
[matlabBatch-VM.ipynb](https://jupyter.designsafe-ci.org/user/name/lab/workspaces/auto-J/tree/CommunityData/Jupyter%20Notebooks%20for%20Civil%20Engineering%20Courses/University_of_Washington/MatlabBatch/matlabBatch-VM.ipynb)


The notebook can be broken down into three main components:

<ol type="a">
  <li>Setup TAPIS/AGAVE APP and run matlab script</li>
  <li>Post process results using python</li>
  <li>Generate report</li>
</ol>

It is emphasized that the main motivation of this notebook is to take advantage of DesignSafe resources. Therefore, relevant details for each component as it pertains to access to DesignSafe-CI are described here.


### Setup tapis/agave app and run Matlab script

The notebook can be executed launching *Jupyter Lab* in Designsafe. This opens a user *docker container* in DesignSafe that includes all the functionality required to execute jupyter commands. This gives immediate access to the **agavepy** module from which it is possible to run any **TAPIS** APP. 


#### Setup job description

A few commands are required to setup a TAPIS OpenSees job in DesignSafe. This requires definition of the TAPIS APP to use, control variables, parameters and inputs. The control variables define the infrastructre resources requested to TACC. The parameters define the executable (matlab), version (xxx), and matlab input script to run. For this particular use case the *matlab-2022a-VM-1.0.0* app is selected. The main steps required to setup an agave job are: 

1. importing agave/tapis, 
2. getting the specific app of interest,
3. defining control variables, parameters and inputs, and
4. encapsulating all data in a *job_description* array 

The python code shown below exemplifies these steps. The complete set of commands is available in the notebook. The *job_description* array includes all the information required to submit the job. 

To receive an alert once a job is complete, users can add their email address to the notification field. This will ensure that they are promptly informed when the job has finished executing.

```python
# Import Agave
from agavepy.agave import Agave
ag = Agave.restore()

# Import general python functions and bring matlab license
from DS_GenFunctions import *
import os
matlab_license = os.environ['MATLAB_LICENSE']

# Get Agave app of interest
app_id = 'matlab-2022a-VM-1.0.0'
app = ag.apps.get(appId=app_id)

# Define control tapis-app variables
control_batchQueue       = 'debug'
control_jobname          = 'matlabBatch-2'
control_nodenumber       = '1'
control_processorsnumber = '1'
control_memorypernode    = '1'
control_maxRunTime       = '00:15:00'

# Define inputs
# Identify folder with input file in DesignSafe
cur_dir        = os.getcwd()
working_dir    = DS_FindDir(cur_dir, ag)
input_filename = working_dir + '/plotMotions.m'

inputs = {}
inputs["inputfile"] = input_filename
inputs["workingDirectory"] = working_dir

# Define parameters
parameters = {}
parameters["_license"] = matlab_license

# Set job_description array
job_description = {}
job_description["appId"]             = (app_id)
job_description["name"]              = (control_jobname)
job_description["batchQueue"]        = (control_batchQueue)
job_description["nodeCount"]         = int(control_nodenumber)
job_description["processorsPerNode"] = int(control_processorsnumber)
job_description["memoryPerNode"]     = (control_memorypernode)
job_description["maxRunTime"]        = control_maxRunTime
job_description["archive"]           = True
job_description["inputs"]            = inputs
job_description["parameters"]        = parameters

# Setting job_description to send an email when job is finished
notification_email = "your email address"
job_description["notifications"]      = [
    {
      "url":notification_email,
      "event":"FINISHED", 
      "persistent":True
    },
]
```


#### Run Matlab script

Submitting a job using DesignSafe HPC resources requires the use of agave job.submit(); and passing the job_description array as argument. Checking the status of a job can be done using jobs.getStatus(). The python code shown below exemplifies these commands.  In the notebook a simple python function is included in *DS_GenFunctions.py* that encapsulates the GetStatus process. When submitting a job, agave copies all the files present in the input folder to a temporary location that is used during execution. After completion agave copies all the results to an archived folder. 

```python
import time
job = ag.jobs.submit(body=job_description)
print(" Job launched. Status provided below")
print(" Can also check in DedignSafe portal under - Workspace > Tools & Application > Job Status")

status = ag.jobs.getStatus(jobId=job["id"])["status"]
while status != "FINISHED":
    status = ag.jobs.getStatus(jobId=job["id"])["status"]
    print(f"Status: {status}")
    time.sleep(15)
```    


### Postprocess Results using Python

With JupyterHub, post-processing can be efficiently carried out using Python, R, or Julia through DesignSafe. Independent of scripting language, postprocessing requires identification of the location of the archived files. This is done interrogating a particular agave job and evaluating the correct folder location. The python code lines shown below exemplifly the steps required for this purpose. 


#### Identify job, archived location and user

``` python
jobinfo = ag.jobs.get(jobId=job.id)
jobinfo.archivePath
user = jobinfo.archivePath.split('/', 1)[0]

import os
%cd ..
cur_dir_name = cur_dir.split('/').pop() 
os.chdir(jobinfo.archivePath.replace(user,'/home/jupyter/MyData'))
if not os.path.exists(cur_dir_name):
    os.makedirs(cur_dir_name)
os.chdir(cur_dir_name)    
```


#### Plot Results

Once in the archived folder (cur_dir_name), postprocessing can be done using python scripts that operate on output files. For the particualar matlab example presented in this use case two scripts are used to evaluate:
1. Time histories of acceleartion, velocity and displacement for any selected motion.  
2. Response spectra for all motions. 

The python code and figures shown below exemplify these steps. All python codes are available in the notebook. 

Plot acceleration, velocity, and displacement time histories for any selected motion (out of 7 provided). 

``` python
# Read motion displacement, velocity and acceleration and concatenate

idx = 2  # selected motion
motionFN = "./motion"+ str(idx)

motionTime = np.loadtxt(motionFN + '.time')
motionDsp  = np.loadtxt(motionFN + '.dsp')
motionVel  = np.loadtxt(motionFN + '.vel')
motionAcc  = np.loadtxt(motionFN + '.acc')
motion = np.array([motionTime, motionDsp, motionVel, motionAcc]).T

# Plot selected motion
# ====================
mYlabel = ['Disp $(m)$','Vel $(m/s)$','Acc $(m/s^2)$']

# Plot acceleration time history
fig1 = plt.figure(num=1, figsize=(8, 8))
plt.clf()
axs1=[]

for ii in range(3):
    axs1.append(fig1.add_subplot(310+ii+1))
    axs1[ii].plot(motion[:,0],motion[:,ii+1], \
                  color='blue', linestyle='solid', linewidth=1.0, \
                  #marker=symbols[0], markersize=6, markerfacecolor = 'white',\
                  label = 'motion '+ str(idx))
    axs1[ii].set_xlabel('Time(s)')
    axs1[ii].set_ylabel(mYlabel[ii])
    axs1[ii].legend()
    axs1[ii].grid(True)
```

<p align="center">
<img src="../img/UC3-Arduino-1.png" alt="Time histories" width="400"/>
</p>
<p align="center"> <b>Fig.2 - Displacement, velocity and acceleration time history for selected motion</b> </p>


Plot response spectra for all motions (7 provided). 
``` python
symbols = ['o', 'o', '^', '^', 's', 's']
colors = ['black', 'blue', 'red', 'green', 'black', 'blue', 'red', 'green']

fig2 = plt.figure(num=2, figsize=(8, 8))
plt.clf()
axs2=[]
axs2.append(fig2.add_subplot(111))

nMotions = 7
for idx in range(1, nMotions+1):
    filename = './RS-motion'+str(idx)+'.out'
    RSm = np.loadtxt(filename)
    
    axs2[0].semilogx(RSm[:,0],RSm[:,3], \
                color=colors[idx], linestyle='solid', linewidth=1.5, \
                #marker=symbols[0], markersize=6, markerfacecolor = 'white', \
                label = 'Motion'+str(idx))
    
axs2[0].set_xlabel('Period(s)')
axs2[0].set_ylabel('Spectral Acc $(m/s^2)$')
axs2[0].legend()
axs2[0].grid(True)  
```

<p align="center">
<img src="../img/UC3-Arduino-2.png" alt="Response spectra" width="400"/>
</p>
<p align="center"> <b>Fig.3 - Response spectra</b> </p>


#### Generate report 

Generating a summary report is a convenient way to present results from lengthy simulations prcesses. In jupyter this can be done invoking any posprocessor available in the docker container image. Among them rst2pdf is commonly distributed with python. For this matlab example a simple ShortReport.rst file is included that collects the results and plots generated in a simple pdf file. The python code shown below, exemplifies this process and include:
1. Running rst2pdf on [ShortReport.rst](FreeField-JupyterNB/ShortReport.rst)
2. Posting the resulting pdf file in the jupyter notebook. For this it is convenient to define the PDF function shown below that specifies the format of the file in the screen. 

Run rst2pdf, assign to pdf_fn, and  call PDF show function 
``` python
import sys
!{sys.executable} -m pip install rst2pdf
os.system('rst2pdf ShortReport.rst ShortReport.pdf')

pdf_fn = jobinfo.archivePath.replace(user, '/user/' + user + '/files/MyData')
pdf_fn += '/'
pdf_fn += cur_dir.split('/')[-1]
pdf_fn += '/ShortReport.pdf'
print pdf_fn

PDF(pdf_fn , (750,600))
```

PDF function 
``` python
class PDF(object):
  def __init__(self, pdf, size=(200,200)):
    self.pdf = pdf
    self.size = size

  def _repr_html_(self):
    return '<iframe src={0} width={1[0]} height={1[1]}></iframe>'.format(self.pdf, self.size)

  def _repr_latex_(self):
    return r'\includegraphics[width=1.0\textwidth]{{{0}}}'.format(self.pdf)
```



